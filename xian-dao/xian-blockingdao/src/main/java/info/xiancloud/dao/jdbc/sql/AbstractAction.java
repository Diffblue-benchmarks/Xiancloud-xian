package info.xiancloud.dao.jdbc.sql;

import info.xiancloud.core.Group;
import info.xiancloud.core.Unit;
import info.xiancloud.core.message.UnitResponse;
import info.xiancloud.core.util.ArrayUtil;
import info.xiancloud.core.util.LOG;
import info.xiancloud.core.util.StringUtil;
import info.xiancloud.dao.group.DaoGroup;
import info.xiancloud.dao.group.unit.DaoUnit;
import info.xiancloud.dao.jdbc.SqlUtils;
import info.xiancloud.dao.utils.string.MapFormat;

import java.sql.Connection;
import java.sql.SQLException;
import java.util.Calendar;
import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * 所有sql action都是非单例的
 *
 * @author happyyangyuan
 */
public abstract class AbstractAction implements Action {

    protected String sqlPattern;
    protected String preparedSql;
    protected List<String> keys;
    protected Object[] sqlParams;
    protected Map map;
    protected Connection connection;
    protected DaoUnit daoUnit;
    /**
     * 模式参数最大长度，用于打印完整sql语句日志时使用；
     * 取值必须小于{@link MapFormat#BUFSIZE}
     */
    public static final int MAX_PATTERN_PARAM_COUNT = 100 < MapFormat.BUFSIZE ? 100 : MapFormat.BUFSIZE;

    public UnitResponse execute(Unit daoUnit, Map map, Connection connection) {
        this.map = map;
        this.connection = connection;
        this.daoUnit = (DaoUnit) daoUnit;
        putLastAutoGeneratedValueIntoMap();
        if (ignore(map, this.daoUnit, connection)) {
            return UnitResponse.createSuccess(String.format("此sql action '%s.%s' 被忽略", this.daoUnit.getName(), getClass().getSimpleName()));
        }

        UnitResponse checkUnitResponse = check(daoUnit, map, connection);
        if (!checkUnitResponse.getCode().equals(Group.CODE_SUCCESS)) {
            return checkUnitResponse;
        }
        try {
            logSql(map);
            return UnitResponse.createSuccess(executeSql(getPreparedSQL(), getSqlParams(), connection));
        } catch (SQLException e) {
            LOG.error("", e);
            String actualSql = null;
            try {
                actualSql = SqlUtils.mapToSql(getSqlPattern(), map);
            } catch (SQLException e1) {
                LOG.error("", e1);
            }
            switch (e.getErrorCode()) {
                case 1062:
                    /**Error: 1062 SQLSTATE: 23000 (ER_DUP_ENTRY)
                     Message: Duplicate entry '%s' for key %d **/
                    return UnitResponse.create(DaoGroup.CODE_REPETITION_NOT_ALLOWED, map, e.getLocalizedMessage());
                default:
                    return UnitResponse.createError(DaoGroup.CODE_SQL_ERROR, actualSql, "执行sql语句出现问题");
            }
        }
    }

    private void putLastAutoGeneratedValueIntoMap() {
        if (!StringUtil.isEmpty(lastAutoGeneratedCol()) && daoUnit != null && daoUnit.getLocalActions().length > 1) {
            for (Action action : daoUnit.getLocalActions()) {
                if (action instanceof InsertAction) {
                    InsertAction insertAction = (InsertAction) action;
                    if (lastAutoGeneratedCol().equals(insertAction.getIdCol()) && insertAction.getId() != null) {
                        map.put(StringUtil.underlineToCamel(lastAutoGenerateToWhichCol()), insertAction.getId());
                    }
                }
            }
        }
    }

    @Override
    public void logSql(Map map) throws SQLException {
        LOG.debug("sql打印已经交给aop去做了，这里全部改为debug级别日志");
        LOG.debug("模式SQL ：" + getSqlPattern());
        LOG.debug("Prepared SQL：" + getPreparedSQL());
        String fullSql = getSqlParams().length <= MAX_PATTERN_PARAM_COUNT ? SqlUtils.mapToSql(getSqlPattern(), map) :
                String.format("模式参数太多则忽略完整sql拼接动作以节省开销。实际传入的模式参数个数为%s，上限为%s", getSqlParams().length, MAX_PATTERN_PARAM_COUNT);
        LOG.debug("完整SQL：" + fullSql);
    }

    protected UnitResponse check(Unit daoUnit, Map map, Connection connection) {
        return UnitResponse.createSuccess("默认不做校验，如果特殊情况，请在子类重载该校验方法");
    }

    protected abstract Object executeSql(String preparedSql, Object[] sqlParams, Connection connection)
            throws SQLException;

    protected String getPreparedSQL() throws SQLException {
        if (preparedSql == null) {
            preparedSql = PatternUtil.getPreparedSql(getSqlPattern());
        }
        return preparedSql;
    }

    protected Object[] getSqlParams() throws SQLException {
        LOG.debug("本方法返回preparedSQL需要的所有变量数组");
        if (sqlParams == null) {
            sqlParams = PatternUtil.getValues(getKeys(), map).toArray();
            for (int i = 0; i < sqlParams.length; i++) {
                if (sqlParams[i] instanceof Calendar) {// 因为prepared
                    // statement不支持calendar类型,所以需要将其其中的calendar转为date
                    sqlParams[i] = ((Calendar) sqlParams[i]).getTime();
                }
            }
        }
        return sqlParams;
    }

    protected String getSqlPattern() throws SQLException {
        if (sqlPattern == null) {
            sqlPattern = PatternUtil.bareError(sqlPattern(map, connection));
            sqlPattern = adjustInClause(sqlPattern);
            // sqlPattern =
            // RouterFactory.getRouter(this).getRoutedSql(sqlPattern);TODO 表路由
        }
        return sqlPattern;
    }

    abstract protected String sqlPattern(Map map, Connection connection) throws SQLException;

    private List<String> getKeys() throws SQLException {
        if (keys == null) {
            this.keys = PatternUtil.getCamelKeys(getSqlPattern());
        }
        return keys;
    }

    /**
     * 上一条insert语句自动生成的主键col名
     */
    public String lastAutoGeneratedCol() {
        return null;
    }

    /**
     * 上一条insert语句自动生成的主键值要填到本action下的哪个字段内
     */
    public String lastAutoGenerateToWhichCol() {
        return lastAutoGeneratedCol();
    }

    public void setConnection(Connection connection) {
        this.connection = connection;
    }

    public void setMap(Map map) {
        this.map = map;
    }

    /**
     * 如果子类重载该方法并返回true
     *
     * @return true 忽略/ false 执行
     */
    protected boolean ignore(Map map, DaoUnit daoUnit, Connection conn) {
        return false;
    }

    @SuppressWarnings("unchecked")
    protected String adjustInClause(String sqlPattern) throws SQLException {
        String regex = " +[i|I][n|N] *\\{[^}]*\\}";
        Pattern pattern = Pattern.compile(regex);
        Matcher matcher = pattern.matcher(sqlPattern);
        while (matcher.find()) {
            String matched = matcher.group();
            for (String key : PatternUtil.getCamelKeys(matched)) {
                if (map.get(key) instanceof Collection) {// 处理集合
                    Collection collection = (Collection) map.get(key);
                    map.put(key, collection.toArray());
                }
                if (map.get(key).getClass().isArray()) {
                    Object[] arrayValue = ArrayUtil.toObjectArray(map.get(key));
                    StringBuilder inClause = new StringBuilder(" in ( ");
                    for (int i = 0; i < arrayValue.length; i++) {
                        String key_i = key + "@" + i;//特殊符号处理key,避免key冲突,特别需要注意的是,不允许使用下划线'_',因为它与转驼峰处理逻辑有冲突
                        map.put(key_i, arrayValue[i]);
                        inClause.append("{").append(key_i).append("},");
                    }
                    String finalInClause = inClause.substring(0, inClause.length() - 1) + " )";
                    sqlPattern = sqlPattern.replaceFirst(regex, finalInClause);
                }
            }
        }
        return sqlPattern;
    }

}
